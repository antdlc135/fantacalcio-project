from models import getModel
class Articles:

  MODEL = "Article"
  DB_TABLE = 'Articles'

  response = {}

  def __init__(self,conn,cur):
    self.conn = conn
    self.cur = cur

  def getAll(self, args):

    query = f"SELECT * FROM {Articles.DB_TABLE}"
    # if you want to change the actual query sent to the db,
    # this is where you should do it

    articleRecords = self.toList(
      self.cur.execute(
      f"""SELECT (row_to_json(t)::jsonb) FROM ({query}) t""").fetchall()
    )
    # you will generally almost never have to change this expression

    response = getModel({"model": Articles.MODEL, "payload": articleRecords})
    # generally, before exposing the data outside this class, they will always have to be first parsed by a model

    self.response["body"] = response
    return self.response

  def getRecordsByIds(self, args):

    if args.get("idList") is None:
      return {"body": {"data": "Missing idslist param", "error": True}}

    idList = list(args.get("idList").split(","))

    query = f"SELECT * FROM {Articles.DB_TABLE} WHERE id = ANY(%s)"

    articleRecords = self.toList(
      self.cur.execute(
      f"""SELECT (row_to_json(t)::jsonb) FROM ({query}) t""", [idList]).fetchall()
    )
    response = getModel({"model": Articles.MODEL, "payload": articleRecords})

    self.response["body"] = response
    return self.response

  def insertRecords(self, args):

    jsonSerializedObjString = args.get("recordsToInsert")

    if jsonSerializedObjString is None:
      return {"body": {"data": "Provide JSON recordsToInsert param", "error": True}}

    recordsToInsert = getModel({"model": Articles.MODEL, "payload": jsonSerializedObjString, "toInsert": True})

    columns = str(tuple([column for column in recordsToInsert[0].keys()])).replace("'","")

    insert = f"INSERT INTO {Articles.DB_TABLE}{columns} VALUES "

    for recordValues in recordsToInsert:
      values =  recordValues.values()
      valueList = tuple([value if value != None else "" for value in values])

      pgCmd = insert + str(valueList)
      print("pg insert cmd: " + pgCmd)

      self.cur.execute(pgCmd)

    self.response["body"] = "Records correctly inserted"
    return self.response

  def updateRecords(self, args):
    # todo
    self.response["body"] = "Records correctly updated"
    return self.response

  def deleteRecords(self, args):
    # todo
    self.response["body"] = "Records correctly deleted"
    return self.response

  def toList(self, fetchedList):
    articleRecords = []
    for record in fetchedList:
      articleRecords.append(record[0])
    return articleRecords










  # test methods
  def createTableTest(self, args):

    # jsonSerializedObjString = args.get("recordsToInsert")
    jsonSerializedObjString = "[{\"body\": \"test_body\", \"author\": \"antdlc\"}]"

    recordsToInsert = getModel({"model": Articles.MODEL, "payload": jsonSerializedObjString, "toInsert": True})
    print("getModel article to Insert Model: " + str(recordsToInsert))

    self.cur.execute(f"""
      CREATE EXTENSION IF NOT EXISTS "pgcrypto";
      CREATE TABLE IF NOT EXISTS {Articles.DB_TABLE} (
        id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        uid UUID DEFAULT gen_random_uuid(),
        body VARCHAR,
        author VARCHAR
      );
      """
    )

    columns = str(tuple([column for column in recordsToInsert[0].keys()])).replace("'","")

    insert = f"INSERT INTO {Articles.DB_TABLE}{columns} VALUES "

    for recordValues in recordsToInsert:
      values =  recordValues.values()
      valueList = tuple([value if value != None else "" for value in values])

      pgCmd = insert + str(valueList)
      print("pg insert cmd: " + pgCmd)

      self.cur.execute(pgCmd)

    response = self.getAll(None)

    return response

  def deleteTableTest(self,args):
    self.cur.execute(f"DROP TABLE {Articles.DB_TABLE}")
    self.conn.commit()
    self.response["body"] = f"{Articles.DB_TABLE} Table Deleted."
    return self.response